import sys, math

drawLib = "pygame"

if drawLib == "pygame":
	import pygame
	pygame.init()
	
	size = width, height = 640, 480
	screen = pygame.display.set_mode(size)
	black = (0,0,0)
	white = (255,255,255)
	red = (255,0,0)
	
	lineThickness = 2
	
	def drawCircle(top, radius, color):   # These two functions should be reimplemented for other platforms
		"""Takes a top (x,y) coordinate and a radius and draws a circle w/ color color (rgb triple)"""
		x, y = top
		pygame.draw.circle(screen, color, (x, y + radius), radius, lineThickness)
	
	def drawLines(points, color):
		pygame.draw.lines(screen, color, False, points, lineThickness)

def GCD(x,y):    # draw platform independent
	"""Greatest common divisor function."""
    #precondition(is_integer(x) and is_integer(y) and x>0 and y>0)
    # postcondition: (x % GCD(x,y)) == 0 and (y % GCD(x,y)) == 0
	big, small = 0, 0
	if x <= y:
		small, big = x, y
	else:
		small, big = y, x
	while big != 0:
		if small > big:
			small, big = big, small
		remainder = big % small
		big = remainder
	assert(big==0 and small != 0)
	return small

def areCoprime(x, y):    # draw platform independent
	# Precondition: should take only positive integers.
	"""Return True if the two numbers are coprime, False otherwise."""
	return (GCD(x, y) == 0)

def add2Points(point1, point2):  # Currently unused
	# Precondition: Should take only homogeneous number tuples of length 2.
	"""Takes two, two-number point-tuples (like (1,2) and (3,4)) and adds their 
	x- and y- coordinates to get a new point-tuple (like (4,6))."""
	point_sum = (point1[0] + point2[0], point1[1] + point2[1])
	return point_sum

def makePointsSquareInCircle(x, y, radius):        # draw platform independent
	# Precondition: x, y, and radius should be non-negative real numbers.
	"""Makes a list of (x,y) tuple points for passing to a drawing method such as 
	pygame.draw.lines, and specifically for drawing a square inside a circle 
	of radius radius with it's top corner at (x,y)."""
	points = []
	points.append((x, y))
	points.append((x + radius, y + radius))
	points.append((x, y + (2 * radius)))
	points.append((x - radius, y + radius))
	points.append((x, y))
	return points

def drawSquareInCircle(x, y, radius, color):  # draw platform dependent, adaptable
	# Precondition: x, y, and radius should be non-negative real numbers, screen should be pygame screen object,
	# color should be an rgb color tuple in range (0,0,0) to (255,255,255)
	"""Draws a circle of radius radius from point (x,y) (center at (x, y+radius)
	with a square inscribed inside of it with it's top corner also at (x,y)"""
	drawCircle((x,y), radius, color)
	drawLines(makePointsSquareInCircle(x, y, radius), color)

def makePointsNGonInCircle(x, y, n, radius):        # draw platform independent
	# Precondition: x, y, and radius should be non-negative real numbers, n should be a positive integer that
	# need not be larger than n/2 and should not be larger than n.
	"""Constructs a list of points to draw an n-sided polygon inscribed in a 
	circle of radius radius from point (x,y), as in makePointsSquareInCircle"""
	center = center_x, center_y = (x, y + radius)
	angleFromCenter = 360./n # central angle of regular n-gon
	points = []
	#points.append((x, y))
	for m in range(0, n+1):
		pointAngleDegrees = 90-m*angleFromCenter
		pointAngleRadians = math.radians(pointAngleDegrees)
		thisPointFromCenter = (radius*math.cos(pointAngleRadians), -(radius*math.sin(pointAngleRadians)))
		thisPoint = (center_x+radius*math.cos(pointAngleRadians), center_y-(radius*math.sin(pointAngleRadians)))
		points.append(thisPoint)
	return points

def drawNGonInCircle(x, y, n, radius, color):      # draw platform dependent, adaptable
	"""Draws an n-sided polygon inscribed in a circle of radius radius from
	point (x,y), as in drawSquareInCircle"""
	drawCircle((x,y), radius, color)
	drawLines(makePointsNGonInCircle(x, y, n, radius), color)

def stepPatternForStar(n, step):            # draw platform independent
	"""Generates an abstract draw-path for a star with n points and step number step. The points of the star
	   are indexed in typical computer science fashion, 0 being the first and n-1 the last"""
	i = 0
	indexList = []
	# Skip around the points of the n-gon to create the draw-path for the star.
	while True:
		breakAfterThis = False
		nextIndex = (i*step)%n
		if nextIndex in indexList:
			breakAfterThis = True
		indexList.append(nextIndex)
		if breakAfterThis:
			break
		i = i + 1
	return indexList

def makeStarPoints(x, y, n, step, radius):                # draw platform independent
	"""Applies the abstract draw-path generated by stepPatternForStar to a concrete start point (for
	   the top point of the star) and radius (of the imaginary circle the star is to be inscribed in)."""
	starPoints = []
	nGonPoints = makePointsNGonInCircle(x, y, n, radius)
	point = False # placeholder value
	i = 0
	indexList = []
	# Skip around the points of the n-gon to create the draw-path for the star.
	indexList = stepPatternForStar(n, step)
	for index in indexList:
		starPoints.append(nGonPoints[index])
	return starPoints

def drawStar(x, y, n, step, radius, color):         # draw platform dependent, adaptable
	"""Draws a star polygon of Schlafli symbol {n/step}, or in other words a star polygon with n points
	   that is drawn by skipping from point i to point i+step repeatedly."""
	drawLines(makeStarPoints(x, y, n, step, radius), color)

def makeMultiStarPoints(x, y, n, step, radius):      # draw platform independent
	"""Makes points like makeStarPoints unless the n and step are not coprime (i.e., they have some common factor 
	   greater than 1). If they are not coprime, make a list of point-lists representing a composite star of 
	   Schlafli symbol k { (n/k) / (step/k) },where k is the greatest common factor of n and step, i.e. if 
	   given n=10 and step=4 make a 10-pointed star {10/4} that is actually a composite of two 5 pointed stars 2{5/2}"""
	listOfStars = []  # will be a list of lists of points, each sub-list representing a star
	lineThickness = 2
	equivalentStep = n-step
	nGonPoints = makePointsNGonInCircle(x, y, n, radius)
	if (not areCoprime(n, step)) or (not areCoprime(n, equivalentStep)): # Not right, test for co-prime-ness, not modulo
		multiStarPoints = []     # will be a list of lists of points, each sub-list representing a star
		stepPattern1 = stepPatternForStar(n, step)
		for i in range(0, step):
			ithStepPattern = []
			for index in stepPattern1:
				ithStepPattern.append((index+i)%n)
			ithStarPoints = []
			for index in ithStepPattern:
				ithStarPoints.append(nGonPoints[index])	
			multiStarPoints.append(ithStarPoints)
		listOfStars = multiStarPoints
	else:
		listOfStars = [makeStarPoints(x, y, n, step, radius)]
	return listOfStars

def drawMultiStar(x, y, n, step, radius, color):       # draw platform dependent
	"""Does the same as drawStar unless the n and step are not coprime (i.e., they have some common factor 
	   greater than 1). If they are not coprime, draw a composite star of Schlafli symbol k { (n/k) / (step/k) },
	   where k is the greatest common factor of n and step, i.e. if given n=10 and step=4 draw a 10-pointed 
	   star {10/4} that is actually a composite of two 5 pointed stars 2{5/2}"""
	listOfStars = makeMultiStarPoints(x, y, n, step, radius)
	for star in listOfStars:
		drawLines(star, color)

def _test():
	screen.fill(white)
	#drawSquareInCircle(320, 240, 100, black)
	#drawNGonInCircle(320, 190, 10, 100, black)

	screen.fill(black)
	#drawLines(makeStarPoints(320, 190, 9, 4, 100), red)
	#drawStar(320, 190, 9, 4, 100, red)
	#drawCircle((320, 190) , 100, red)
	drawMultiStar(320, 190, 17, 6, 100, red)
	
	pygame.display.update()
	while 1:
		for event in pygame.event.get():
			if event.type == pygame.QUIT: sys.exit()

if __name__ == "__main__": _test()