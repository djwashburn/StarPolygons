import sys, pygame, math
pygame.init()

def GCD(x,y):
    """Greatest common divisor function."""
    #precondition(is_integer(x) and is_integer(y) and x>0 and y>0)
    # postcondition: (x % GCD(x,y)) == 0 and (y % GCD(x,y)) == 0
    big, small = 0, 0
    if x <= y:
        small, big = x, y
    else:
        small, big = y, x
    while big != 0:
        if small > big:
            small, big = big, small
        remainder = big%small
        big = remainder
    assert(big==0 and small != 0)
    return small

def areCoprime(x, y):
    # Precondition: should take only positive integers.
    """Return True if the two numbers are coprime, False otherwise."""
    return (GCD(x,y) == 0)

def add2Points(point1, point2):
    # Precondition: Should take only homogeneous number tuples of length 2.
    """Takes two, two-number point-tuples (like (1,2) and (3,4)) and adds their 
    x- and y- coordinates to get a new point-tuple (like (4,6))."""
    point_sum = (point1[0] + point2[0], point1[1] + point2[1])
    return point_sum

def makePointsSquareInCircle(x, y, radius):
    # Precondition: x, y, and radius should be non-negative real numbers.
    """Makes a list of (x,y) tuple points for passing to pygame.draw.lines,
    and specifically for drawing a square inside a circle of radius radius
    with it's top corner at (x,y)."""
    points = []
    points.append((x, y))
    points.append((x + radius, y + radius))
    points.append((x, y + (2 * radius)))
    points.append((x - radius, y + radius))
    points.append((x, y))
    return points

def drawSquareInCircle(x, y, radius, screen, color):
    # Precondition: x, y, and radius should be non-negative real numbers, screen should be pygame screen object,
    # color should be an rgb color tuple in range (0,0,0) to (255,255,255)
    """Draws a circle of radius radius from point (x,y) (center at (x, y+radius)
    with a square inscribed inside of it with it's top corner also at (x,y)"""
    lineThickness = 2
    pygame.draw.circle(screen, color, (x, y + radius), radius, 1)
    pygame.draw.lines(screen, color, False, makePointsSquareInCircle(x, y, radius), lineThickness)

def makePointsNGonInCircle(x, y, n, radius):
    # Precondition: x, y, and radius should be non-negative real numbers, n should be a positive integer that
    # need not be larger than n/2 and should not be larger than n.
    """Constructs a list of points to draw an n-sided polygon inscribed in a 
    circle of radius radius from point (x,y), as in makePointsSquareInCircle"""
    center = center_x, center_y = (x, y + radius)
    angleFromCenter = 360./n # central angle of regular n-gon
    points = []
    #points.append((x, y))
    for m in range(0, n+1):
        pointAngleDegrees = 90-m*angleFromCenter
        pointAngleRadians = math.radians(pointAngleDegrees)
        thisPointFromCenter = (radius*math.cos(pointAngleRadians), -(radius*math.sin(pointAngleRadians)))
        thisPoint = (center_x+radius*math.cos(pointAngleRadians), center_y-(radius*math.sin(pointAngleRadians)))
        points.append(thisPoint)
    return points

def drawNGonInCircle(x, y, n, radius, screen, color):
    """Draws an n-sided polygon inscribed in a circle of radius radius from
    point (x,y), as in drawSquareInCircle"""
    lineThickness = 2
    pygame.draw.circle(screen, color, (x, y + radius), radius, 1)
    pygame.draw.aalines(screen, color, False, makePointsNGonInCircle(x, y, n, radius), lineThickness)

def stepPatternForStar(n, step):
    """Generates an abstract draw-path for a star with n points and step number step. The points of the star
       are indexed in typical computer science fashion, 0 being the first and n-1 the last"""
    i = 0
    indexList = []
    # Skip around the points of the n-gon to create the draw-path for the star.
    while True:
        breakAfterThis = False
        nextIndex = (i*step)%n
        if nextIndex in indexList:
            breakAfterThis = True
        indexList.append(nextIndex)
        if breakAfterThis:
            break
        i = i + 1
    return indexList

def makeStarPoints(x, y, n, step, radius):
    """Applies the abstract draw-path generated by stepPatternForStar to a concrete start point (for
       the top point of the star) and radius (of the imaginary circle the star is to be inscribed in)."""
    starPoints = []
    nGonPoints = makePointsNGonInCircle(x, y, n, radius)
    point = False # placeholder value
    i = 0
    indexList = []
    # Skip around the points of the n-gon to create the draw-path for the star.
    indexList = stepPatternForStar(n, step)
    for index in indexList:
        starPoints.append(nGonPoints[index])
    return starPoints

def drawStar(x, y, n, step, radius, screen, color):
    """Draws a star polygon of Schlafli symbol {n/step}, or in other words a star polygon with n points
       that is drawn by skipping from point i to point i+step repeatedly."""
    lineThickness = 2
    pygame.draw.aalines(screen, color, False, makeStarPoints(x, y, n, step, radius), lineThickness)

def drawMultiStar(x, y, n, step, radius, screen, color):
    """Does the same as drawStar unless the n and step are not coprime (i.e., they have some common factor 
       greater than 1). If they are not coprime, draw a composite star of Schlafli symbol k { (n/k) / (step/k) },
       where k is the greatest common factor of n and step, i.e. if given n=10 and step=4 draw a 10-pointed 
       star {10/4} that is actually a composite of two 5 pointed stars 2{5/2}"""
    lineThickness = 2
    equivalentStep = n-step
    nGonPoints = makePointsNGonInCircle(x, y, n, radius)
    if (not areCoprime(n, step)) or (not areCoprime(n, equivalentStep)): # Not right, test for co-prime-ness, not modulo
        stepPattern1 = stepPatternForStar(n, step)
        for i in range(0, step):
            ithStepPattern = []
            for index in stepPattern1:
                ithStepPattern.append((index+i)%n)
            ithStarPoints = []
            for index in ithStepPattern:
                ithStarPoints.append(nGonPoints[index])    
            pygame.draw.aalines(screen, color, False, ithStarPoints, lineThickness)
    else:
        drawStar(x, y, n, step, radius, screen, color)


def _test():
    size = width, height = 640, 480
    screen = pygame.display.set_mode(size)
    black = (0,0,0)
    white = (255,255,255)

    screen.fill(white)
    #drawSquareInCircle(320,240,100,screen, black)
    #drawNGonInCircle(320, 190, 10, 100, screen, black)

    screen.fill(black)
    #drawStar(320, 190, 9, 4, 100, screen, (255,0,0))
    drawMultiStar(320, 190, 17, 6, 100, screen, (255,0,0))
    
    pygame.display.update()
    while 1:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: sys.exit()

if __name__ == "__main__": _test()